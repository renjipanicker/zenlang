namespace TestBasic;

public routine int testNative(const string& s) native;

public routine int testRoutine(const int& x) {
    return 12345;
}

public function (int ri, string rs)testFunction(const int& x) {
    return (67890, "testfn");
}

public test testBasicExpr {
    auto i = 0;
    auto s = "xx";
    auto e = (1 + 2) * 3;
    auto n = (1 > 2) ? 1 : 2;
    auto t = "yy %{x}\n" @ {"n":n};
    auto l = [1,2,3];
    auto d = ["a":1,"b":2,"c":3];
    auto r = testRoutine(123);
    auto f = testFunction(456);

    assert(i == 0, s == "xx", e == 9, n == 2);
    unused(t, l, d, r, f);

    return (true);
}

public enum MyEnum {
    C1;
    C2;
};

public struct MyStructDecl;

public struct MyBase {
    j = 0;
};

public struct MyStruct : MyBase {
    i = 0;
};

public function (int r)testAdvancedExpr(const int& x, const MyStruct& myStruct, const MyEnum& myEnum) {
    auto v = x;
    auto m = myStruct.i;
    auto n = myEnum;
    auto a = typeof(myStruct);
    auto p = pointer<MyBase>(myStruct);
    auto w = value<MyBase>(p);
    auto u = value<MyStruct>(p);
    auto t = <MyStruct>p;
    auto y = <long>v;

    auto q = &myStruct;
    auto s = &q;
    auto z = &<MyStruct>p;

    auto r = *p;
    unused(v, m, n, a, p, w, u, y, r, s, t, q, z);
    return (67890);
}

public test testFunction001 {
    auto myStruct = MyStruct{i:0;};
    auto e = MyEnum.C1;
    auto c = testAdvancedExpr(321, myStruct, e);
    unused(c);
    return (true);
}

public test testInnerRootFunction {
    function (int i)innerFunction(int j) {
        return (2);
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public test testInnerChildFunction {
    testFunction innerFunction {
        return (2, "aa");
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public test testInnerChildFunctionClosure {
    auto i = 0;
    testFunction innerFunction {
        return (i, "aa");
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public test testAnonymousFunction {
    auto a = testFunction {
        return (2, "aa");
    };
    auto r = a(2);
    unused(r);
    return (true);
}

public test testAnonymousFunctionWithClosure {
    auto i = 0;
    auto a = testFunction {
        return (i, "aa");
    };
    auto r = a(2);
    unused(r);
    return (true);
}

public test testIfStatement {
    auto i = 0;
    auto j = 0;
    if(i > 2) {
        j = 3;
    }
    unused(j);
    return (true);
}

public test testIfElseStatement {
    auto i = 0;
    auto j = 0;
    if(i > 2) {
        j = 3;
    } else {
        j = 5;
    }
    unused(j);
    return (true);
}

public test testWhileStatement {
    auto i = 0;
    while(i < 2) {
        i++;
    }
    return (true);
}

public test testDoWhileStatement {
    auto i = 0;
    do {
        i++;
    } while(i < 2);
    return (true);
}

public test testForExprStatement {
    auto j = 0;
    auto i = 0;
    for(i = 0; i < 10; ++i) {
        j += i;
    }
    return (true);
}

public test testForInitStatement {
    auto j = 0;
    for(auto i = 0; i < 10; ++i) {
        j += i;
    }
    return (true);
}

public test testForeachListStatement {
    auto j = 0;
    auto l = [1,2,3];
    //const list<int>& l2 = l; /// \todo should be valid
    foreach(i in l) {
        j += i;
    }
    return (true);
}

public test testForeachDictStatement {
    auto j = 0;
    auto l = ['a':1, 'b':2,'c':3];
    foreach(k,v in l) {
        unused(k);
        j += v;
        continue;
    }
    return (true);
}

public test testSwitchValueStatement {
    auto j = 0;
    switch(j) {
        case 1: {
            break;
        }
        case 2: {
            break;
        }
        default: {
            break;
        }
    }
    return (true);
}

public test testSwitchExprStatement {
    auto j = 0;
    switch {
        case j == 1: {
        }
        case j == 2: {
        }
        default: {
        }
    }
    return (true);
}

public function (int ri, string rs)runFunctionTest(const int& x) {
    print "runFunctionTest %{x}\n" @ {"x":x};
    return (67890, "run");
}

public test testFunctor {
    auto f = runFunctionTest[];
    unused(f);
    return (true);
}

public function ()getFunctor(const runFunctionTest& f) {
    return ();
}

public runFunctionTest derivedFunctionTest {
    return (12345, "derived");
}

public test testPassDerivedFuncion {
    auto f = derivedFunctionTest[];
    getFunctor(f);
    return (true);
}

public test testRunExpr {
    auto f = run runFunctionTest(456);
    unused(f);
    return (true);
}

struct InStruct {
};

struct PtrStruct {
    pointer<InStruct> p;
};

test testPtrStruct {
    auto s = PtrStruct{p : pointer<InStruct>(InStruct{});};
    unused(s);
    return (true);
}

public test testLists {
    auto s = [1,2];
    auto t = s[0];
    s[1] = 3;
//    s[3] = 4;
//    print "testLists %{@t}\n" @ {@t:t};
    unused(s, t);
    return (true);
}

public test testDicts {
    auto s = ["a":1, "b":2];
    auto t = s["b"];
    s[@c] = 3;
    auto u = s[@c];
    unused(s, t, u);
    return (true);
}

public main MyMain {
    auto f = run runFunctionTest(908);
    unused(f);
    return (0);
}

public function void testVoidFunction() {
}
