namespace TestBasic;

public routine int testNative(const string& s) native;

public routine int testRoutine(const int& x) {
    return 12345;
}

public function (int ri, string rs)testFunction(const int& x) {
    return (67890, "testfn");
}

public function testBasicExpr : test {
    auto i = 0;
    auto s = "xx";
    auto e = (1 + 2) * 3;
    auto n = (1 > 2) ? 1 : 2;
    auto t = "yy %{x}\n" @ {"n":n};
    auto l = [1,2,3];
    auto d = ["a":1,"b":2,"c":3];
    auto r = testRoutine(123);
    auto f = testFunction(456);

    assert(i == 0, s == "xx", e == 9, n == 2);
    unused(t, l, d, r, f);

    return (true);
}

public enum MyEnum {
    C1;
    C2;
};

public struct MyStructDecl;

public struct MyBase {
    auto j = 0;
};

public struct MyStruct : MyBase {
    auto i = 0;
};

public function (int r)testAdvancedExpr(const int& x, const MyStruct& myStruct, const MyEnum& myEnum) {
    auto v = x;
    auto m = myStruct.i;
    auto n = myEnum;
    auto a = typeof(myStruct);
    auto p = pointer<MyBase>(myStruct);
    auto w = value<MyBase>(p);
    auto u = value<MyStruct>(p);
    auto t = <MyStruct>p;
    auto y = <long>v;

    auto q = &myStruct;
    auto s = &q;
    auto z = &<MyStruct>p;

    auto r = *p;
    unused(v, m, n, a, p, w, u, y, r, s, t, q, z);
    return (67890);
}

public function testFunction001 : test {
    auto myStruct = MyStruct{i:0;};
    auto e = MyEnum.C1;
    auto c = testAdvancedExpr(321, myStruct, e);
    unused(c);
    return (true);
}

public function testInnerRootFunction : test {
    function (int i)innerFunction(int j) {
        return (2);
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public function testInnerChildFunction : test {
    function innerFunction : testFunction {
        return (2, "aa");
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public function testInnerChildFunctionClosure : test {
    auto i = 0;
    function innerFunction : testFunction {
        return (i, "aa");
    }
    auto f = innerFunction(2);
    auto o = innerFunction[];
    auto r = o(2);
    unused(f, o, r);
    return (true);
}

public function testAnonymousFunction : test {
    auto a = testFunction {
        return (2, "aa");
    };
    auto r = a(2);
    unused(r);
    return (true);
}

public function testAnonymousFunctionWithClosure : test {
    auto i = 0;
    auto a = testFunction {
        return (i, "aa");
    };
    auto r = a(2);
    unused(r);
    return (true);
}

public function testIfStatement : test {
    auto i = 0;
    auto j = 0;
    if(i > 2) {
        j = 3;
    }
    unused(j);
    return (true);
}

public function testIfElseStatement : test {
    auto i = 0;
    auto j = 0;
    if(i > 2) {
        j = 3;
    } else {
        j = 5;
    }
    unused(j);
    return (true);
}

public function testWhileStatement : test {
    auto i = 0;
    while(i < 2) {
        i++;
    }
    return (true);
}

public function testDoWhileStatement : test {
    auto i = 0;
    do {
        i++;
    } while(i < 2);
    return (true);
}

public function testForExprStatement : test {
    auto j = 0;
    auto i = 0;
    for(i = 0; i < 10; ++i) {
        j += i;
    }
    return (true);
}

public function testForInitStatement : test {
    auto j = 0;
    for(auto i = 0; i < 10; ++i) {
        j += i;
    }
    return (true);
}

public function testForeachListStatement : test {
    auto j = 0;
    auto l = [1,2,3];
    //const list<int>& l2 = l; /// \todo should be valid
    foreach(i in l) {
        j += i;
    }
    return (true);
}

public function testForeachDictStatement : test {
    auto j = 0;
    auto l = ['a':1, 'b':2,'c':3];
    foreach(k,v in l) {
        unused(k);
        j += v;
        continue;
    }
    return (true);
}

public function testSwitchValueStatement : test {
    auto j = 0;
    switch(j) {
        case 1: {
            break;
        }
        case 2: {
            break;
        }
        default: {
            break;
        }
    }
    return (true);
}

public function testSwitchExprStatement : test {
    auto j = 0;
    switch {
        case j == 1: {
        }
        case j == 2: {
        }
        default: {
        }
    }
    return (true);
}

public function (int ri, string rs)runFunctionTest(const int& x) {
    print "runFunctionTest %{x}\n" @ {"x":x};
    return (67890, "run");
}

public function testFunctor : test {
    auto f = runFunctionTest[];
    unused(f);
    return (true);
}

public function ()getFunctor(const runFunctionTest& f) {
    return ();
}

public function derivedFunctionTest : runFunctionTest {
    return (12345, "derived");
}

public function testPassDerivedFuncion : test {
    auto f = derivedFunctionTest[];
    getFunctor(f);
    return (true);
}

public function testRunExpr : test {
    auto f = run runFunctionTest(456);
    unused(f);
    return (true);
}

struct InStruct {
};

struct PtrStruct {
    pointer<InStruct> p;
};

function testPtrStruct : test {
    auto s = PtrStruct{p : pointer<InStruct>(InStruct{});};
    unused(s);
    return (true);
}

public function testLists : test {
    auto s = [1,2];
    auto t = s[0];
    auto u = [float, 1,2];
    s[1] = 3;
//    s[3] = 4;
//    print "testLists %{@t}\n" @ {@t:t};
    unused(s, t, u);
    return (true);
}

public function testDicts : test {
    auto s = ["a":1, "b":2];
    auto t = s["b"];
    auto u = [string:float, "a":1, "b":2];
    s[@c] = 3;
    auto v = s[@c];
    unused(s, t, u, v);
    return (true);
}

public function MyMain : main {
    auto f = run runFunctionTest(908);
    unused(f);
    return (0);
}

public function void testVoidFunction() {
}

struct MyIndexStruct {
    //routine const Handle& at(const string& k) native;
};

function testAutoInitList : test {
    float a = 3;
    unused(a);

    list<float> s = [1, 2];
    unused(s);

    list< list<float> > t = [[1, 2], [3, 4]];
    unused(t);

    list< dict<string, float> > u = [["a":1, "b":2], ["c":3, "d":4]];
    unused(u);

    dict< string, list<float> > v = ["a":[1, 2], "b":[3, 4]];
    unused(v);

    dict< string, dict<string, float> > w = ["h":["a":1, "b":2], "i":["c":3, "d":4]];
    unused(w);

    return (true);
}

struct MyAutoInnerStruct {
    auto name = "";
};

struct MyAutoStruct {
    auto i = 0;
    auto s = "";
    list<float> fl;
    list<pointer<MyAutoInnerStruct> > lps;
};

struct MyDerivedStruct : MyAutoStruct {
};

function testAutoInitStruct : test {
//    MyAutoStruct aps0 = auto {i:3;};
    MyAutoStruct aps1 = {i:3;};

//    list<MyAutoStruct> als0 = [ auto {i:123; s:"xx";fl:[1,2];}, auto {i:456; s:"yy";fl:[3,4];}];
    list<MyAutoStruct> als1 = [ {i:123; s:"xx";fl:[1,2];}, {i:456; s:"yy";fl:[3,4];}];

    pointer<int> pi = 314;
    pointer<MyAutoStruct> pps0 = &MyAutoStruct{i:3;};
//    pointer<MyAutoStruct> apps0 = auto {i:3;};
    pointer<MyAutoStruct> apps1 = {i:3;};

    pointer<MyAutoStruct> pps1 = MyAutoStruct{i:3;};

    list< pointer<MyAutoStruct> > lps = [&MyAutoStruct{i:4;}];
//    list< pointer<MyAutoStruct> > alps0 = [auto {i:4;}];
    list< pointer<MyAutoStruct> > alps1 = [{i:4;}];

//    MyAutoStruct mys0 = auto {i:123; s:"xx"; fl:[1, 2]; lps:[auto {name:"n1";}];};
    MyAutoStruct mys1 = {i:123; s:"xx"; fl:[1, 2]; lps:[{name:"n1";}];};

    list< pointer<MyAutoStruct> > alpds1 = [MyDerivedStruct{i:4;}];
    return (true);
}
